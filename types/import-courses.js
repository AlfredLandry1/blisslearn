const { PrismaClient } = require('@prisma/client');
const fs = require('fs');
const csv = require('csv-parser');
const path = require('path');

const prisma = new PrismaClient();

// Configuration
const BATCH_SIZE = 100; // Taille de lot r√©duite pour √©viter les timeouts
const CSV_FILE_PATH = path.join(__dirname, '..', 'processed_courses.csv');

// Mapping des colonnes CSV vers les champs de la base de donn√©es
const CSV_TO_DB_MAPPING = {
  course_id: 'course_id',
  title: 'title',
  link: 'url',
  platform: 'platform',
  institution: 'provider',
  instructor: 'extra',
  description: 'description',
  skills: 'skills',
  category: 'extra',
  level_normalized: 'level',
  duration_hours: 'duration',
  price_numeric: 'price',
  rating_numeric: 'rating',
  reviews_count_numeric: 'extra',
  enrolled_students: 'extra',
  course_type: 'certificate_type',
  mode: 'format',
  availability: 'extra',
  source_file: 'extra'
};

// Fonction pour nettoyer et valider les donn√©es
function cleanData(rawData) {
  const cleaned = {};
  const extraData = {};
  
  for (const [csvField, dbField] of Object.entries(CSV_TO_DB_MAPPING)) {
    let value = rawData[csvField];
    
    // Nettoyage des valeurs
    if (value !== undefined && value !== null && value !== '') {
      value = value.toString().trim();
      
      // Conversion des valeurs num√©riques
      if (csvField === 'rating_numeric') {
        const numValue = parseFloat(value);
        if (!isNaN(numValue) && numValue >= 0 && numValue <= 5) {
          value = numValue;
        } else {
          value = null;
        }
      } else if (csvField === 'price_numeric') {
        const numValue = parseFloat(value);
        if (!isNaN(numValue) && numValue >= 0) {
          value = numValue.toString();
        } else {
          value = '0'; // Gratuit si pas de prix
        }
      }
      
      // Conversion de la dur√©e
      if (csvField === 'duration_hours') {
        const hours = parseFloat(value);
        if (!isNaN(hours) && hours > 0) {
          value = `${hours}h`;
        } else {
          value = null;
        }
      }
      
      // Gestion des champs extra (JSON)
      if (dbField === 'extra') {
        extraData[csvField] = value;
        continue;
      }
      
      // Limitation de la taille des champs texte
      if (typeof value === 'string') {
        if (dbField === 'title' && value.length > 191) {
          value = value.substring(0, 188) + '...';
        } else if (dbField === 'platform' && value.length > 191) {
          value = value.substring(0, 191);
        } else if (dbField === 'provider' && value.length > 191) {
          value = value.substring(0, 191);
        }
      }
      
      cleaned[dbField] = value;
    } else {
      cleaned[dbField] = null;
    }
  }
  
  // Conversion du champ extra en JSON
  if (Object.keys(extraData).length > 0) {
    cleaned.extra = JSON.stringify(extraData);
  } else {
    cleaned.extra = null;
  }
  
  return cleaned;
}

// Fonction pour v√©rifier si un cours existe d√©j√†
async function courseExists(courseId) {
  try {
    const existingCourse = await prisma.course.findFirst({
      where: { course_id: courseId },
      select: { id: true }
    });
    return !!existingCourse;
  } catch (error) {
    console.error('Erreur lors de la v√©rification du cours:', error.message);
    return false;
  }
}

// Fonction pour ins√©rer un lot de donn√©es avec gestion d'erreurs
async function insertBatch(batch) {
  let successCount = 0;
  let errorCount = 0;
  let duplicateCount = 0;
  
  for (const item of batch) {
    try {
      // V√©rifier si le cours existe d√©j√†
      if (item.course_id && await courseExists(item.course_id)) {
        duplicateCount++;
        continue;
      }
      
      // Ins√©rer le cours
      await prisma.course.create({
        data: item,
      });
      successCount++;
    } catch (error) {
      errorCount++;
      console.error(`‚ùå Erreur pour l'item ${item.course_id || 'sans ID'}:`, error.message);
    }
  }
  
  return { successCount, errorCount, duplicateCount };
}

// Fonction principale d'import - Version synchrone corrig√©e
async function importCourses() {
  console.log('üöÄ D√©but de l\'import des cours...');
  console.log(`üìÅ Fichier CSV: ${CSV_FILE_PATH}`);
  
  const startTime = Date.now();
  let totalProcessed = 0;
  let totalInserted = 0;
  let totalErrors = 0;
  let totalDuplicates = 0;
  let batch = [];
  
  return new Promise((resolve, reject) => {
    const stream = fs.createReadStream(CSV_FILE_PATH)
      .pipe(csv())
      .on('data', (row) => {
        try {
          totalProcessed++;
          
          // Nettoyer et valider les donn√©es
          const cleanedData = cleanData(row);
          
          // Ajouter les timestamps
          cleanedData.createdAt = new Date();
          cleanedData.updatedAt = new Date();
          
          batch.push(cleanedData);
          
          // Traiter le lot quand il atteint la taille d√©finie
          if (batch.length >= BATCH_SIZE) {
            // Traiter le lot de mani√®re synchrone
            insertBatch(batch).then(({ successCount, errorCount, duplicateCount }) => {
              totalInserted += successCount;
              totalErrors += errorCount;
              totalDuplicates += duplicateCount;
              
              console.log(`‚úÖ Lot trait√©: ${batch.length} enregistrements, ${successCount} ins√©r√©s, ${errorCount} erreurs, ${duplicateCount} doublons (Total: ${totalInserted})`);
            }).catch(error => {
              console.error('‚ùå Erreur lors du traitement du lot:', error.message);
              totalErrors += batch.length;
            });
            
            batch = []; // Vider le lot
          }
          
          // Afficher le progr√®s tous les 1000 enregistrements
          if (totalProcessed % 1000 === 0) {
            console.log(`üìä Progression: ${totalProcessed} enregistrements trait√©s...`);
          }
          
        } catch (error) {
          console.error(`‚ùå Erreur lors du traitement de l'enregistrement ${totalProcessed}:`, error.message);
          totalErrors++;
        }
      })
      .on('end', async () => {
        try {
          // Traiter le dernier lot s'il reste des donn√©es
          if (batch.length > 0) {
            const { successCount, errorCount, duplicateCount } = await insertBatch(batch);
            totalInserted += successCount;
            totalErrors += errorCount;
            totalDuplicates += duplicateCount;
            console.log(`‚úÖ Dernier lot trait√©: ${batch.length} enregistrements, ${successCount} ins√©r√©s, ${errorCount} erreurs, ${duplicateCount} doublons`);
          }
          
          const endTime = Date.now();
          const duration = (endTime - startTime) / 1000;
          
          console.log('\nüéâ Import termin√©!');
          console.log(`üìä Statistiques:`);
          console.log(`   - Enregistrements trait√©s: ${totalProcessed}`);
          console.log(`   - Enregistrements ins√©r√©s: ${totalInserted}`);
          console.log(`   - Doublons ignor√©s: ${totalDuplicates}`);
          console.log(`   - Erreurs: ${totalErrors}`);
          console.log(`   - Dur√©e: ${duration.toFixed(2)} secondes`);
          console.log(`   - D√©bit: ${(totalProcessed / duration).toFixed(2)} enregistrements/seconde`);
          
          resolve({
            totalProcessed,
            totalInserted,
            totalDuplicates,
            totalErrors,
            duration
          });
          
        } catch (error) {
          console.error('‚ùå Erreur lors du traitement du dernier lot:', error);
          reject(error);
        }
      })
      .on('error', (error) => {
        console.error('‚ùå Erreur lors de la lecture du fichier CSV:', error);
        reject(error);
      });
  });
}

// Fonction pour v√©rifier la base de donn√©es
async function checkDatabase() {
  try {
    const totalCourses = await prisma.course.count();
    console.log(`üìä Nombre total de cours en base: ${totalCourses}`);
    
    // Afficher quelques exemples
    const sampleCourses = await prisma.course.findMany({
      take: 5,
      select: {
        id: true,
        title: true,
        platform: true,
        provider: true,
        rating: true,
        price: true,
        level: true
      },
      orderBy: {
        id: 'desc'
      }
    });
    
    console.log('\nüìã Exemples de cours import√©s:');
    sampleCourses.forEach((course, index) => {
      console.log(`   ${index + 1}. ${course.title || 'Sans titre'} (${course.platform || 'N/A'}) - Rating: ${course.rating || 'N/A'}, Prix: ${course.price || 'Gratuit'}, Niveau: ${course.level || 'N/A'}`);
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la v√©rification de la base de donn√©es:', error);
  }
}

// Fonction pour nettoyer la base de donn√©es (optionnel)
async function clearCourses() {
  try {
    console.log('üßπ Nettoyage de la table des cours...');
    const deletedCount = await prisma.course.deleteMany({});
    console.log(`‚úÖ ${deletedCount.count} cours supprim√©s`);
  } catch (error) {
    console.error('‚ùå Erreur lors du nettoyage:', error);
  }
}

// Fonction principale
async function main() {
  try {
    console.log('üîç V√©rification de la connexion √† la base de donn√©es...');
    await prisma.$connect();
    console.log('‚úÖ Connexion √† la base de donn√©es √©tablie');
    
    // V√©rifier l'√©tat initial
    console.log('\nüìä √âtat initial de la base de donn√©es:');
    await checkDatabase();
    
    // Demander confirmation pour le nettoyage (optionnel)
    const readline = require('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    const answer = await new Promise((resolve) => {
      rl.question('\n‚ùì Voulez-vous nettoyer la table des cours avant l\'import ? (y/N): ', resolve);
    });
    rl.close();
    
    if (answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes') {
      await clearCourses();
    }
    
    // Importer les cours
    console.log('\nüöÄ D√©but de l\'import...');
    const result = await importCourses();
    
    // V√©rifier l'√©tat final
    console.log('\nüìä √âtat final de la base de donn√©es:');
    await checkDatabase();
    
    console.log('\n‚úÖ Script termin√© avec succ√®s!');
    
  } catch (error) {
    console.error('‚ùå Erreur fatale:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Ex√©cuter le script si appel√© directement
if (require.main === module) {
  main();
}

module.exports = {
  importCourses,
  checkDatabase,
  cleanData,
  clearCourses
}; 